import supabase from '../../config/supabaseClient';
import { Tag, Ratings } from '../../types/database-types';
import { getGroupIdWithUserId } from './groupHelper';
import { notifyAllocatedGroups } from './notificationHelper';
import { convertRatingsToTags } from './utilityHelper';

/**
 * Runs the allocation algorithm and updates the last run time.
 *
 * @returns {Promise<string>} - A promise that resolves with the current date and time as a string.
 * @throws {Error} - Throws an error if the allocation is locked or there is an issue updating the last run time.
 */
export const runAllocationAlgorithm = async (): Promise<string> => {
  const allocationLocked = await isAlgorithmLocked();
  if (allocationLocked) throw new Error('Allocation is locked, perform manual allocation');

  await supabase.functions.invoke('group_project_allocation');

  const currentTime = new Date();
  const { error: updateError } = await supabase
    .from('allocation_status')
    .update({ last_run: currentTime.toISOString() })
    .eq('boolean', false);
  if (updateError) throw new Error(updateError.message);

  return currentTime.toLocaleString();
};

/**
 * Locks the allocation algorithm to prevent further automatic allocations.
 *
 * @returns {Promise<void>} - A promise that resolves when the allocation algorithm is locked.
 * @throws {Error} - Throws an error if there is an issue locking the algorithm.
 */
export const lockAllocationAlgorithm = async (): Promise<void> => {
  await notifyAllocatedGroups();
  const { error } = await supabase.from('allocation_status').update({ boolean: true }).eq('boolean', false);
  if (error) throw new Error(error.message);
};

/**
 * Checks if the allocation algorithm is currently locked.
 *
 * @returns {Promise<boolean>} - A promise that resolves with a boolean indicating if the algorithm is locked.
 * @throws {Error} - Throws an error if there is an issue fetching the allocation status.
 */
export const isAlgorithmLocked = async (): Promise<boolean> => {
  const { data: status, error } = await supabase.from('allocation_status').select('boolean').single();
  if (error) throw new Error(error.message);

  return status.boolean;
};

/**
 * Retrieves the last run time of the allocation algorithm.
 *
 * @returns {Promise<string | null>} - A promise that resolves with the last run time as a string, or null if no run time is found.
 * @throws {Error} - Throws an error if there is an issue fetching the last run time.
 */
export const getAlgorithmLastRun = async (): Promise<string | null> => {
  const { data, error } = await supabase.from('allocation_status').select('last_run').single();
  if (error) throw new Error(error.message);
  if (data) return new Date(data.last_run!).toLocaleString();
  return null;
};

/**
 * Fetch the group ratings generated by the algorithm for a specific student.
 *
 * @param {string} studentId - The ID of the student to fetch data for.
 * @returns {Promise<Tag[]>} A promise that resolves to an array of group ratings with project tags as the object key.
 * @throws {Error} If there is an error while fetching the group ratings.
 */
export const getGroupRatingsWithUserId = async (studentId: string): Promise<Tag[]> => {
  const { data, error } = await supabase
    .from('group_members')
    .select('group_id, groups (group_id, group_ratings)')
    .eq('user_id', studentId)
    .single();

  if (error) throw new Error(error.message);
  if (!data.groups) throw new Error('Failed to fetch group ratings');

  const ratings = data.groups.group_ratings as Ratings;
  return convertRatingsToTags(ratings);
};

/**
 * Fetch the individual ratings generated by the algorithm for a specific student.
 *
 * @param {string} studentId - The ID of the student to fetch data for.
 * @returns {Promise<Tag[]>} A promise that resolves to an array of individual ratings with project tags as the object key.
 * @throws {Error} If there is an error while fetching the individual ratings.
 */
export const getIndividualRatings = async (studentId: string): Promise<Tag[]> => {
  const { data, error } = await supabase.from('students').select('individual_marks').eq('user_id', studentId).single();
  if (error) {
    throw new Error(error.message);
  }
  const ratings = data.individual_marks as Ratings;
  return convertRatingsToTags(ratings);
};

/**
 * Fetch the group name and allocated project for a specific student.
 *
 * @param {string} studentId - The ID of the student to fetch data for.
 * @returns {Promise<{ groupName: string; allocatedProject: string }>} A promise that resolves to an object containing the group name and allocated project.
 * @throws {Error} If there is an error while fetching the group name or allocated project.
 */
export const getAllocationWithUserId = async (
  studentId: string
): Promise<{ groupName: string; allocatedProject: string }> => {
  const groupId = (await getGroupIdWithUserId(studentId)).group_id;
  const { data, error } = await supabase
    .from('allocations')
    .select('groups (name), projects (project_number)')
    .eq('group_id', groupId)
    .single();
  if (error) throw new Error(error.message);
  if (!data.groups) throw new Error('Failed to fetch group name');
  if (!data.projects) throw new Error('Failed to fetch allocated project');

  return {
    groupName: data.groups.name,
    allocatedProject: `P${data.projects.project_number}`,
  };
};
